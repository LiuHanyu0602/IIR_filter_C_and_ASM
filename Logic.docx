I. 	Discussion of Program Logic
In .section .bss, spaces are reserved for x feedforward queue and y feedback queue with a length of 4 * N_MAX bytes each. In addition, three 4-byte variables are declared: inited_flag, which is to ensure initialization runs only once, last_N, to track filter order changes, and head_index, which points to the most recent entry in the circular buffers.
The program in .section .text starts with pushing regesters onto the stack, releasing regesters R4, R5, R6, R8 and LR. Then the initializing process is executed, where data intaken from the C program is loaded into registers and the arrays are initialized to zeros. The variable head_index is initialized to N-1. A judgement statement is evaluated to make sure the initialization is not to be executed any more after the first time.
After initialization, y_n is calculated. The base term y_n=(b_0×x_n)/a_0 +⋯ is calculated individually, whereas the rest terms are accumulated through a loop. In each loop, a pair of the stored x and y values is taken out, multiplied by the provided coefficients and accumulated, starting from the beginning of the buffer. In a circular buffer, this process is implemented through an individual index i, which acts as a shift distance from the head_index during the loop. The pointer goes downwards from the head_index, and a judgement statement makes sure that the index is wrapped around once becoming negative. Once each term is calculated, i is incremented by one, and the next loop starts. The pattern is followed until i reaches N.
After the summation, the circular buffer is updated, where head_index is advanced by one and wrapped around if needed. Also, the new x_n and computed y_n values are stored into the buffers at the index, rewriting the existing data there, therefore completing enqueue and dequeue operations in one time.
Upon this time, the calculation for y_n is completed, and the queues are updated. The result y_n is divided by 100 according to the problem statement and stored into R0, which will be retuned to C. Finally, the values pushed into the stack is restored to the registers, and the restored PC register brings the execution back to C code.

II. 	Discussion of Improvements
Utilizing a circular buffer: In the original code, the program records the history of past inputs and outputs by shifting all elements of the buffers one position backward on each iteration. Essentially, this achieves the function of a queue, so it is possible to replace it with a circular bufffer, where no value is shifted and only the pointer is moved. Once a new value is to be enqueued, the pointer is incremented by 1 and the last value in the queue is overridden. This change reduces the time complexity of buffer update process from O(N) to O(1). 
Stack spill for x_n instead of saving it in registers： We save x_n to the stack (a 4-byte stack slot) (SUB SP,#4 / STR [SP]). So that we do not have to push/pop R7 and R11 (kept free as frame registers) and still keep live values available with just one LDR when needed.
One-time initialization only (skip clearing on every call)： Each calculation of y[n] in the IIR filter requires historical samples x[n-1..n-N] and historical outputs y[n-1..n-N]. If we reset the history buffer to zero with every call, the filter would lose its “memory.” However, if we never reset it, the first call might read dirty data. Therefore, we decided to reset it on the first call and preserve the history thereafter. Our specific approach is: Place X_list[], Y_list[], and initial_flag in the .bss segment. Additionally, determine whether it is the first call by checking initial_flag.
Use LSLS #2 instead of multiply to form byte offsets: This minimal ALU instructions per iteration, prevents redoing address arithmetic.
Single pass over coefficients (fwd + feedback merged): We compute the feedforward term (b[i+1]*X[i])/a0 and the feedback term (a[i+1]*Y[i])/a0 within the same loop. Then we accumulate y_full += term1 − term2. This approach of replacing two loops with one reduces the loop overhead by half.
Leaf Function： This function does not call subroutines. Therefore, we only push the actual callee save registers used and return via POP {R...,pc}. Consequently, we use fewer stack operations.
Merged for loops: We merged the two passes (“sum” and “shift”) into a single right-to-left pipeline loop. In each iteration we first use the old X[j]/Y[j] to accumulate (b[j+1]*X[j] − a[j+1]*Y[j]) / a0, and then move the old X[j-1]/Y[j-1] into slot j. This change eliminates an entire second loop, cuts branch overhead in half, and reduces memory traffic because each history pair is loaded once and reused for both computation and shifting .

III. 	Additional Outcomes
When looking for information of infinite impulse response (iir) filters, we find that the given formula is called the Direct Form I (DF1) expression. Mathematically, it is equivalent to the Direct Form II (DF2) expression. 
Here, a_0 is considered as 1 by default. Therefore, when calculating, the coefficients should be adjusted respectively. The proof of consistency of the 2 forms requires performing z-transform to the signal. Changing to DF2 can reduce the required stack space and loop run time, since instead of using 2 buffer lists, this algorithm only uses 1. 
We have developed our code based on DF2. However, we find that the error between the two forms is significant and tend to accumulate over iterations. As a result, we decided to give up on this optimization and preserve our code for future references. The screenshot of the code is pasted here.
